# This are only some convenience plotting functions
BiocManager::install("MSnbase")

source("https://bioconductor.org/biocLite.R")
biocLite(c("MSnbase", "pRoloc", "pRolocdata", "pRolocGUI"))


asetwd("/home/javan/Desktop/zandi_javan/full_lfqcluster/result")
dir()
data <- read.table("xtandem.clustering.spec_counts.tsv",header = T, sep = '\t')

data
library(ggplot2)
library(RColorBrewer)
library(reshape2)
library(cowplot)
library(MSnbase)

org.options <- options()

# create a nicer ggplot theme
my_theme <- function(base_size = 12, base_family = "", flip_axis = F) {
  flip_axis_theme <- theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  res <- theme_bw(base_size=base_size, base_family=base_family) %+replace% 
    theme(strip.background = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(), 
          axis.line = element_line(colour = "#333333")
    )
  
  if (flip_axis) {
    res <- res + flip_axis_theme
  }
  
  return(res)
}

# add some convenience functions
setPlotSize <- function(height, width) {
  options(repr.plot.height=height, repr.plot.width = width)
}

resetPlotSize <- function() {
  options(org.options)
}

showPlot <- function(plot.obj, width, height, filename = NULL) {
  if (!is.null(filename) && dir.exists("Figures")) {
    svg(paste0("Figures/", filename, ".svg"), 
        width=width, height=height)
    print(plot.obj)
    dev.off()
  }
  
  setPlotSize(height, width)
  print(plot.obj)
}

#Load data; The data is loaded into MSnbase objects.
# libraries used to process the data
#================================================================
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("MSnbase")
BiocManager::install("edgeR")
#=================================================================

suppressPackageStartupMessages(library(MSnbase))
suppressPackageStartupMessages(library(edgeR))

source("msnbase_adapter.R")

#The following function is used to load the TSV files generated by the clustering nextflow workflow into MSnbase objects. 
#Every file is loaded twice once with and once without the PSMs added through clustering.

loadData <- function(basename, engines = c("msgf", "xt")) {
  msnsets <- list()
  
  for (engine in engines) {
    data <- read.csv(paste0(basename, "-", engine, ".prot"), sep = "\t")
    
    # remove any ambiguous assignments (non-unique peptides)
    data <- data[!grepl(";", data$protein), ]
    
    data$engine <- engine
    data <- data[data$protein != "", ]
    data$sample_id <- data$filename
    
    # Load the complete (with clustering) results
    msnsets[[engine]] <- loadAsMSnSet(filename = data, 
                                      sample.column = "sample_id", 
                                      spec.id.column = "spec_id", 
                                      sequence.column = "sequence", 
                                      protein.column = "protein", 
                                      truncate.filename = T)
    
    # indicate that these files do contain clustering PSMs
    for (i in 1:length(msnsets[[engine]])) {
      pData(msnsets[[engine]][[i]])$original_search_result <- F
      sampleNames(msnsets[[engine]][[i]]) <- paste0(sampleNames(msnsets[[engine]][[i]]), "_", engine, "_clus")
    }
    names(msnsets[[engine]]) <- paste0(names(msnsets[[engine]]), "_", engine, "_clus")
    
    # Load the results without the clustering PSMs
    msnsets[[paste0(engine, "-org")]] <- loadAsMSnSet(filename = data[data$changed_by_clustering == "false", ], 
                                                      sample.column = "sample_id", 
                                                      spec.id.column = "spec_id", 
                                                      sequence.column = "sequence", 
                                                      protein.column = "protein", 
                                                      truncate.filename = T)
    
    for (i in 1:length(msnsets[[paste0(engine, "-org")]])) {
      pData(msnsets[[paste0(engine, "-org")]][[i]])$original_search_result <- T
      sampleNames(msnsets[[paste0(engine, "-org")]][[i]]) <- 
        paste0(sampleNames(msnsets[[paste0(engine, "-org")]][[i]]), "_", engine, "_search")
    }
    names(msnsets[[paste0(engine, "-org")]]) <- paste0(names(msnsets[[paste0(engine, "-org")]]), "_", engine, "_search")
  }
  
  # merge all
  msnsets <- unlist(msnsets, recursive = T)
  
  # quantify the data
  quant_data <- list()
  
  for (i in 1:length(msnsets)) {
    quant_data[[i]] <- quantifyMSnSet(object = msnsets[[i]], method = "count")
    quant_data[[i]] <- updateFvarLabels(quant_data[[i]], 
                                        sampleNames(quant_data[[i]])[1])
  }
  
  # combine the quant data
  message("Combining data...")
  
  # get all exprs objects
  all.exprs <- lapply(quant_data, function(x) data.frame(exprs(x)))
  all.prot <- unique(unlist(sapply(all.exprs, rownames)), recursive = T)
  
  # add NA for missing prots
  for (i in 1:length(all.exprs)) {
    missing.prot <- all.prot[!all.prot %in% rownames(all.exprs[[i]])]
    all.exprs[[i]][missing.prot, ] <- NA
    # sort all lists the same way
    all.exprs[[i]] <- all.exprs[[i]][all.prot, ]
  }
  
  # combine the exprs data
  combined.expr <- do.call("cbind", all.exprs)
  rownames(combined.expr) <- all.prot
  colnames(combined.expr) <- sapply(quant_data, function(x) sampleNames(x)[1])
  
  combined.expr[is.na(combined.expr)] <- 0
  
  # create a new DGEList object
  dge.list <- DGEList(counts = combined.expr, 
                      samples = data.frame(row.names=colnames(combined.expr), sample.id = colnames(combined.expr)),
                      genes = data.frame(row.names=rownames(combined.expr), uniprot = rownames(combined.expr)), 
                      group = rep(1, ncol(combined.expr)))
  
  # add metadata
  dge.list$samples$original_search_result <- grepl("_search", rownames(dge.list$samples))
  dge.list$samples$method <- factor(
    ifelse(dge.list$samples$original_search_result, "Search engine", "Clustering enriched"),
    levels = c("Search engine", "Clustering enriched"))
  dge.list$samples$engine <- "MSGF+"
  dge.list$samples$engine[grep("_xt_", rownames(dge.list$samples))] <- "X!Tandem"
  
  # TODO: add the protein length as a feature variable
  
  # remove excessive annotation columns
  #accession.col <- grep("accession\\.", fvarLabels(combined_quant_data))[1]
  #length.col <- grep("length\\.", fvarLabels(combined_quant_data))[1]
  #fData(combined_quant_data) <- fData(combined_quant_data)[, c(accession.col, length.col)]
  #fvarLabels(combined_quant_data) <- c("accession", "length")
  
  return(dge.list)
}




















